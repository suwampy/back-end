같은 자료형의 변수를 하나의 묶음으로 다루는 것
저장 된 값마다 인덱스가 지정되며 인덱스는 0부터 시작
0. 기본 선언 방법
- 배열 선언
자료형[ ] 배열명; or 자료형 배열명[];
int[ ] arr; or
int arr[ ]; - 배열 할당
자료형[ ] 배열명; or 자료형 배열명[];
int[ ] arr; or
int arr[ ]; - 선언과 할당을 동시에
int[ ] arr1 = new int[5]; - 초기화 배열명[인덱스] = 값;
arr1[0] = 0;
배열의 장점 : 대입을 할 때 인덱스의 위치나 값이
 일정한 규칙이 있다면 반복문 사용 가능
 > 0번 인덱스부터
 배열의 길이 -1 인덱스까지 반복
- 3 -
1. 배열
(0) 변수 선언
 int i;
 -> 메모리 공간에 값을 담을 박스를 만드는 과정
 이 때 메모리의 stack이라는 영역에 할당
(1) 배열 선언
 int[ ] iArr;
 - 배열을 선언하게 되면 변수 선언과 같이
 stack 영역에 공간이 생기지만
 이 공간은 값을 담는 용도X 주소를 보관할 용도 O
 -> 주소 값을 담는 변수는 레퍼런스 변수
(2) 배열 할당
// iArr = new int[]; 반드시 크기 지정
iArr = new int[5]; - new 연산자를 통해 배열을 할당하게 되면
 메모리의 heap 영역에 해당 배열의 크기만큼
 공간이 만들어지고 그 공간의 주소 값을
 stack 영역의 레퍼런스 변수에 저장. 따라서 해당 배열에 값을 넣거나 수정할 때
 해당 주소를 참조해서 사용
 - 위의 배열 선언과 할당을 동시
int[] iArr2 = new int[5];
char[] cArr = new char[10];
double[] dArr = new double[20];
heap영역의 메모리에는 변수를 만든다거나 직접적으로 접근
을 하지 못하는 영역. 주소를 통해서만 찾아 갈 수 있음
char[] cArr = new char[5];
int[] iArr = new int[3];
여기까지는 배열을 선언 및 할당한 것
아직 실제 값을 넣지 않음 (초기화X) → 지역변수와 달리 아직 초기화를 안했는데
 오류 없이 잘 출력 됨 → 배열을 따로 초기화 하지 않는다면
 jvm이 지정한 기본 값으로 배열이 초기화 됨 → 왜냐면 heap 영역은 값이 없는 공간이 존재할 수 없음
(3) 배열의 단점
- 한 번 지정한 크기는 변경이 불가능함
- 따라서 크기를 바꾸려면
 다시 배열 크기를 지정해서 할당해야함
iArr = new int[10]; > 10이라는 크기의 배열을 heap 영역에 새로 생성하고
 새로 생성한 주소 값을
 iArr이라는 레퍼런스 변수에 덮어쓴 것
 > 기존에 참조하고 있던 연결이 끊기고
 새로운 곳을 참조하고 있으므로
 예전 배열은 어느 곳에도 참조 되지 않고
 heap 영역을 둥둥 떠다니는 상태
 > 일정 시간이 지나면 가비지 컬렉터가
 더 이상 쓸모없다고 판단하여 지워줌(자동 메모리 관리)
지금 할당 된 배열을 지우려면???
iArr = null;
레퍼런스 변수에 null 값이 들어가게 되면 주소 값이 null로
바뀜
-> heap에 있는 공간과 연결고리 끊어짐
-> 가비지 컬렉터가 삭제
(+) 최댓값 최솟값 구하기
- arr[0]으로 최댓값과 최솟값을 담을 변수 초기화
 int max = arr[0]; int min = arr[0]; - 1번 인덱스부터 배열 끝까지 비교할 수 있는 반복문
for(int i = 1; i < arr.length; i++) { if(max < arr[i]) { max = arr[i]; } if(min > arr[i]) { min = arr[i]; }
}
System.out.println("최대값 : " + max);
System.out.println("최소값 : " + min);
2. 복사
(1) 얕은 복사
 int[] origin = { 1, 2, 3, 4, 5 }; int[] copy = origin; - 같은 곳(같은 주소값) 을 참조하고 있어서
 원본값이 변경되면 복사본값도 변경됨
 - 복사 된 새로운 배열을 만들기 위해서는
 깊은 복사가 필요함!!!
- 4 -
(2) 깊은 복사
 ① for문
 새로운 배열을 생성하여
 반복문을 통해 실제 값을 집어 넣는 방법
int[ ] origin = { 1, 2, 3, 4, 5 };
int[ ] copy = new int[5];
for (int i = 0; i < origin.length; i++) { copy[i] = origin[i]; }
 ② System.arraycopy() 메소드를 이용
int[ ] origin = { 1, 2, 3, 4, 5 };
int[ ] copy = new int[10]; // 넉넉하게 크게 생성
System.arraycopy(원본 배열명, 복사 시작할 인덱스, 복사본 배열명, 복사본 배열의 복사 시작 인덱스, 복사
길이);
System.arraycopy(origin,0,copy,2, origin.length);
 - origin 배열을 copy 배열에 복사하는데
 이때 origin 배열의 0번 인덱스부터
 마지막에 넣은 길이만큼을
 copy 배열의 2번 인덱스부터 채우겠다는 의미
System.arraycopy( )
-> 복사 위치나 복사할 개수를 지정할 수 있음
for문을 이용해 인덱스 조절하여 같은 기능 구현 가능
 ③ Arrays 클래스에서 제공하는 copyOf() 메소드
int[ ] origin = { 1, 2, 3, 4, 5 };
복사본 배열
= Arrays.copyOf(원본 배열, 복사할 길이);
int[] copy
 = Arrays.copyOf(origin, 3);
Arrays.copyOf( )
-> 내가 지정한 길이만큼 무조건 크기 할당
-> 지정한 길이가 복사하고자 하는 길이보다
 클 경우 기존 배열에 있는 내용 다 복사
-> 지정한 길이가 복사하고자 하는 길이보다
 작을 경우 기본 배열에서 지정한 길이만큼만 복사
 ④ clone() 메소드 이용한 복사
 - 시작 인덱스 지정할 수 없으며 원본 배열
 통채로 복사해서 새로운 배열을 할당함
int[] origin = { 1, 2, 3, 4, 5 };
int[] copy = origin.clone();
