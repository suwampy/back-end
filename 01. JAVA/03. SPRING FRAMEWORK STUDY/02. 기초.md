## 1. 인터페이스를 사용하는 프로그래밍
- 의존 중인 클래스가 의존 관계의 구체적인 클래스를 직접 참조한다면, 두 클래스 사이에 긴밀한 결합이 생긴다.
=> 의존 관계의 구현을 변경하려면 의존 중인 클래스도 변경해야 한다.
- <b>자바 인터페이스는</b> 구현 클래스가 준수해야 하는 계약을 정의한다. 따라서 클래스가 인터페이스에 의존한다면
해당 의존 관계의 구현을 변경하더라도 의존 중인 클래스를 변경할 필요가 없다.
   1. 설계 방식
      - 의존 관계에 구체적인 구현 클래스가 아닌 <b>의존 관계 인터페이스를 참조하는 빈 클래스</b>를 만든다.
      - 의존 중인 빈에 주입하고 싶은 구체적인 구현을 지정할 수 있는 <bean> 엘리먼트를 정의한다.
      - ex) MyBank 애플리케이션
        ![a1](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbS8iP7%2FbtqF1omxOJt%2FsXk3SrYNe8TR0MWx55Tec1%2Fimg.png)
      - ex) applicationContext.xml - MyBank 애플리케이션의 XML파일
         ```sh
         <bean id="controller"
               class="ControllerImpl 경로">
            <property name="fixedDepositService" ref="service"/>
         </bean>
            
         <bean id="service"
               class="FixedDepositServiceImpl 경로">
            <property name="fixedDepositDao" ref="dao" />
         </bean>
         
         <bean id="dao" class="FixxedDepositHibernateDao  경로">
         </bean>
         
         ```

## 2. 정적 팩토리 메서드나 인스턴트 팩토리 메서드를 사용해 빈 만들기
- 스프링은 인수가 없는  생성자 지원 여부에 상관없이 클래스의 인스턴스를 만들고 관리할 수 있다.
   1. 정적 팩토리 메서드로 빈 초기화하기
      - 정적 메서드에 전달된 인수를 기반으로  FixedDepositDao의 인스턴스를 만들어 반환하고 정적 팩토리 메서드를 정의하는 FixedDepositDaoFactory 클래스
      ```sh
      public class FixedDepositDaoFactory {
         private FixedDepositDaoFactory() {}
         
         public static FixedDepositDao getFixedDepositDao(String daoType, ...) {
            FixedDepositDao fixedDepositDao = null;
            
            if("jdbc".equalsIgnoreCase(daoType)) {
               fixedDepositDao = new FixedDepositJdbcDao();
            }
            if("hibernate".equalsIgnoreCase(daoType)) {
               fixedDepositDao = new FixedDepositHibernateDao();
            }
            ...
            return fixedDepositDao;
         }
      }
            
      ```
      

## 3. 생성자 기반 DI

## 4. 설정 정보를 빈에 전달하기

## 5. 빈 스코프
1. 싱글턴 스코프 : XML 파일에 정의된 모든 빈의 디폴트 스코프
2. 프로토타입 스코프
