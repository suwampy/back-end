## 6. 애너테이션 기반 개발

1. @Component - 스프링 빈 식별하기
   - 타입 수준의 애너테이션으로 <b>클래스가 스프링 빈을 표현한다는 사실</b>을 나타낸다.
   - 애플리케이션에서는 컨트롤러, 서비스, 데이터 접근 객체에 따라 특별한 @Component를 사용하도록 권장한다. (컨트롤러에는 @Controller를, 
   서비스에는 @Service를, DAO에는 @Repository를 설정 : 이 애너테이션들은 @Component로 메타 애너테이션이 되어있음.)
   - @Service 애너테이션 사용하기
   
   ```java
   @Service(value="fixedDepositService") // 스프링 컨테이너에 빈을 어떤 이름으로 등록할지 지정하는 value 속성을 받음. 
                                         // value 속성은 <bean>엘리먼트의 id 속성과 같은 역할을 함
   public class FixedDepositServiceImpl implements FixedDepositService { .... } // fixedDepositService 빈으로 스프링 컨테이너에 등록됨
   ```
   
2. @Autowired - 객체의 타입으로 의존 관계 자동 연결하기
   - 의존 관계를 '객체의 타입으로' 자동 연결. 생성자 수준, 메서드 수준, 필드 수준에서 사용할 수 있음.
   - Autowired 애너테이션을 필드 수준에서 사용하기
   
   ```java
   @Service(value="accountStatementService")
   public class AccountStatementServiceImpl implments AccountStatementService {
    
      @Autowried // @Autowired 애너테이션을 accountStatementDao 필드에 설정. : 필드가 자동 연결 됨
      private AccountStatementDao accountStatementDao; // 스프링 컨테이너에서 AccountStatementDao 타입 빈을 얻어서
                                                       // accountStatmenDao 필드에 대입
   }
   ```
   
   - Autowrired 애너테이션을 메서드 수준에서 사용하기
   
   ```java
   @Service("cutomerRegistrationService")
   @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
   public class CustomerRegistrationServiceImpl implents CustomerRegistrationService {
      
      private CustomerRegistrationDetails customerRegistrationDetails;
   
      @Autowried // @Autowried를 obtainCustomerRegistrationDetails 메서드에 설정 : 메서드 인수가 자동 연결 됨
      public void obtainCustomerRegistrationDetails(CustomerRegistrationDetails customerRegistrationDetails) {
         // 메서드의 CustomerRegistrationDetails는 타입을 사용해 자동 연결된다.
         // 빈 인스턴스가 생성된 다음에 @Autowried를 설정한 메서드가 자동으로 호출되고,
         // @Autowired를 설정한 필드에는 일치하는 빈 인스턴스가 주입된다.
         this.customerRegistrationDetails = customerTegistrationDetails;
      }
   
   }
   ```
   
   - 생성자에 @Autowired를 설정하기
   
   ```java
   @Serivce(value="customerRequestService")
   public class CustomerRequestServiceImpl implments CustomerRequestService {
      private CustomerRequestDetails customerRequestDetails;
      private CustomerRequestDao customerRequestDao;
      
      @Autowried // @Autowried를 CustomerRequestServiceImpl 의 생성자에 설정. : 생성자 인수가 자동 연결됨
      public CustomerRequestSerivceImpl(CustomerRequestDetails customerRequestDetails, CustomeRequestDao customerRequestDao) {
         // 생성자의 CustomerRequestDetails와 CustomerRequestDao 인수가 객체의 타입으로 자동 연결됨.
         this.customerRequestDetails = customerRequestDetails;
         this.customerRequestDao = customerRequestDao;
      }
   }
 
   ``` 

3.  @Qualifier - 빈 이름으로 의존 관계 자동 연결하기
   - @Qualifier와 @Autowired를 함께 사용하면 의존 관계를 빈 이름으로 자동 연결할 수 있다.
   - 빈 이름으로 자동 연결하기 위해 @Qualifier를 필드 수준, 메서드 수준, 생성자 수준에서 사용한다.
   - @Qualifier 애너테이션 사용하기
   
   ```java
   @Serivce(value="fixedDepositService")
   public class FixedDepositServiceImpl implments FixedDepositService {
   
      @Autowired
      @Qualifier(value="myFixedDepositDao") // myFixedDepositDao 필드에 인스턴스를 대입할 빈의 이름 지정
      private FixedDepositDao myFixedDepositDao;
      // 스프링은 먼저 @Autowired를 설정한 필드, 생성자 인수, 메서드 인수의 객체 타입으로 후보 빈을 찾음
      // 그 후, 스프링은 @Qualifier를 사용해 자동 연결 후보 목록에서 유일한 빈을 구별
      
      // ex) 스프링은 myFixedDepositDao에 대해 먼저 FixedDepositDao 타입 빈을 찾음 (@Autowired를 설정한 필드의 타입으로)
      // 그 다음, 발견한 자동 연결 대상 후보 빈 목록에서(@Qualifier를 사용) 이름이 myFixedDepositDao인 빈을 찾음.
      // 이름이 myFixedDepositDao인 빈을 찾으면 스프링은 그 빈을 myFixedDepositDao 필드에 대입
   }
   
   ```
